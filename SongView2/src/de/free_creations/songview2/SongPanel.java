/*
 * Copyright 2011 Harald Postner .
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.free_creations.songview2;

import de.free_creations.guicomponents.SwingExecutor;
import de.free_creations.midisong.GenericTrack;
import de.free_creations.midisong.GenericTrack.EventHandler;
import de.free_creations.midisong.SongSession;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sound.midi.Track;
import javax.swing.SwingUtilities;
import javax.swing.Timer;
import org.openide.util.Exceptions;

/**
 *
 * @author Harald Postner <Harald at H-Postner.de>
 */
public class SongPanel extends SongCanvasImpl {

  static final private Logger logger = Logger.getLogger(SongPanel.class.getName());
  /**
   * The proposed size of one measure in pixels.
   */
  private static final double MAESUREDEFAULTPX = 130;
  /**
   * a PixelToMidiFactor that permits to display the currently loaded song in a
   * reasonable resolution. This value is automatically adjusted when a new
   * sequence is loaded.
   */
  private double defaultPixelToMidiFactor = 10.0D;

  private double verticalZoomFactor = 1.0D;
  private final double zoomStep = 0.1d;
  private static final int BETWEEN_TRACK_DIST_PIXELS = 10;
  private static final int DIRECTOR_TO_FIRST_TRACK_DIST = 10;
  private static final int DEFAULT_MIDI_BANDHEIGHT = 30;
  private static final double MAX_VERTICAL_ZOOM = 10.0;
  private static final double MIN_VERTICAL_ZOOM = 1.0 / 2.0;

  private static class TrackToBandConnector implements EventHandler {

    private final TrackBand trackBand;

    public TrackToBandConnector(TrackBand trackBand) {
      this.trackBand = trackBand;
    }

    @Override
    public void onMuteChange(boolean value) {
      trackBand.setActive(!value);
    }

    @Override
    public void onAttenuationChange(float value) {
      //ignore
    }
  }
  /**
   * The size (in pixels) of the jump- margin on both window borders. When the
   * cursor moves into this margin the display will shift to the next page.
   */
  //private final long JUMPMARGIN = 20;
  /**
   * The size (in midiTick) of the jump- margin on both window borders. When the
   * cursor moves into this margin the display will shift to the next page.
   */
  private final long JUMPMARGINMIDI = 3 * 480; // one bar (assuming 3/4)

  private DirectorBand directorBand;
  private ArrayList<TrackBand> trackBands = new ArrayList<TrackBand>();
  private SongSession session = null;
  private final static int cursorUpdatePeriode = 100; // in milliseconds
  /**
   * The Handler that reacts on cursor update events generated by the cursor
   * timer.
   */
  private final ActionListener cursorUpdateTask = new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
      SongPanel.this.synchronizeCursor();
    }
  };
  private final Timer cursorTimer = new Timer(cursorUpdatePeriode, cursorUpdateTask);
  private LeftVoidZone leftVoidZone;
  private RightVoidZone rightVoidZone;
  private volatile boolean playing = false;

  /**
   * The sessionListener monitors the song-session to see when it starts or
   * stops playing.
   */
  /**
   * This class transmits changes of the song-session to the song display.
   */
  private class SessionToViewConnector implements PropertyChangeListener {

    private final Dimensions dimensions;

    public SessionToViewConnector(Dimensions dimensions) {
      this.dimensions = dimensions;
    }

    @Override
    public void propertyChange(PropertyChangeEvent evt) {
      if (SongSession.PROP_PLAYING.equals(evt.getPropertyName())) {
        boolean playing = (Boolean) evt.getNewValue();
        SongPanel.this.sessionPlayingChanged(playing);
      } else if (SongSession.PROP_STARTPOINT.equals(evt.getPropertyName())) {
        dimensions.setStartPointMidi((Long) evt.getNewValue());
        setCursorVisible((Long) evt.getNewValue());
      } else if (SongSession.PROP_LOOPSTARTPOINT.equals(evt.getPropertyName())) {
        dimensions.setLoopStartMidi((Long) evt.getNewValue());
      } else if (SongSession.PROP_LOOPENDPOINT.equals(evt.getPropertyName())) {
        dimensions.setLoopEndMidi((Long) evt.getNewValue());
      } else if (SongSession.PROP_LOOPING.equals(evt.getPropertyName())) {
        setLoopActive((Boolean) evt.getNewValue());
      }
    }
  }

  /**
   * This class transmits changes of the song-display to the song-Session.
   */
  private class ViewToSessionConnector implements PropertyChangeListener {

    private final SongSession session;

    public ViewToSessionConnector(SongSession session) {
      this.session = session;
    }

    @Override
    public void propertyChange(PropertyChangeEvent evt) {
      if (Prop.STARTPOINT_MIDI.equals(evt.getPropertyName())) {
        session.setStartPoint((Long) evt.getNewValue());
      } else if (Prop.LOOPSTART_MIDI.equals(evt.getPropertyName())) {
        session.setLoopStartPoint((Long) evt.getNewValue());
      } else if (Prop.LOOPEND_MIDI.equals(evt.getPropertyName())) {
        session.setLoopEndPoint((Long) evt.getNewValue());
      }
    }
  }

  /**
   * Paint an example for use in an application construction environment.
   */
  private class DesignTimePainter implements Runnable {

    @Override
    public void run() {
      try {
        getDimensions().setPixelToMidiFactor(30.0D);
        getDimensions().setMinimumPixel(-20);
        getDimensions().setMaximumPixel(600);
        getDimensions().setLoopStartPixel(20);
        getDimensions().setLeadInEndPixel(150);
        getDimensions().setLeadOutStartPixel(400);
        getDimensions().setLoopEndPixel(450);

        getDimensions().setStartPointPixel(180);
        getDimensions().setCursorPixel(200);

        addZone(new LeftVoidZone(SongPanel.this));
        //addZone(new LeadInZone(SongPanel.this));
        //addZone(new LeadOutZone(SongPanel.this));
        addZone(new RightVoidZone(SongPanel.this));

        TrackBand trackBand = new TrackBand(SongPanel.this);
        trackBand.setY(80);
        addBand(trackBand);
        trackBands.add(trackBand);
        directorBand = new DirectorBand(SongPanel.this);
        addBand(directorBand);
        setDefaultDraggingLayer(directorBand);

        addZone(new LoopZone(SongPanel.this));
        addZone(new StartPointZone(SongPanel.this));
        addZone(new CursorZone(SongPanel.this));
        repaint();
      } catch (IOException ex) {
        Exceptions.printStackTrace(ex);
      }
    }
  }

  /**
   * Builds a song panel. If we are running in an application construction
   * environment (i.e. NetBeans Matisse GUI Builder) this constructor will
   * display an example with one track. In a runtime environment this
   * constructor will display an empty panel.
   */
  public SongPanel() {
    this(java.beans.Beans.isDesignTime());
  }

  /**
   * This constructor is package private and might be used to test the
   * designTime feature.
   *
   * @param designTime set to true to start in design-time mode.
   */
  SongPanel(final boolean designTime) {
    super();
    if (designTime) {
      SwingUtilities.invokeLater(new DesignTimePainter());
    }
  }

  void setLoopActive(boolean active) {
    if (!SwingUtilities.isEventDispatchThread()) {
      throw new RuntimeException("Must be called from EventDispatchThread.");
    }
    rightVoidZone.setActive(active);
    leftVoidZone.setActive(active);
  }

  /**
   * Indicate that the given track is enabled. An enabled track is shown a more
   * prominent way.
   *
   * @param trackIndex
   * @param enabled
   */
  public void setEnabled(int trackIndex, boolean enabled) {
    if (!SwingUtilities.isEventDispatchThread()) {
      throw new RuntimeException("Must be called from EventDispatchThread.");
    }
    TrackBand track = trackBands.get(trackIndex);
    track.setEnabled(enabled);
  }

  public double getVerticalZoom() {
    return verticalZoomFactor;
  }

  /**
   *
   * @param value
   */
  public void setVerticalZoom(double newValue) {
    if (!SwingUtilities.isEventDispatchThread()) {
      throw new RuntimeException("Must be called from EventDispatchThread.");
    }

    if (newValue > MAX_VERTICAL_ZOOM) {
      newValue = MAX_VERTICAL_ZOOM;
    }
    if (newValue < MIN_VERTICAL_ZOOM) {
      newValue = MIN_VERTICAL_ZOOM;
    }
    double oldValue = verticalZoomFactor;
    if (Math.abs(oldValue - newValue) < Math.abs(oldValue * zoomStep)) {
      return;
    }

    verticalZoomFactor = newValue;

    int newY = Band.PREF_BANDHEIGHT + DIRECTOR_TO_FIRST_TRACK_DIST;
    for (TrackBand t : trackBands) {
      newY = zoomTrackBand(t, newY);
    }
    repaint();

  }

  private int zoomTrackBand(TrackBand trackBand, int newY) {

    trackBand.setBandHeight((int) (DEFAULT_MIDI_BANDHEIGHT * verticalZoomFactor));
    trackBand.setLyricsHeightPixels((int) (TrackBand.defaultLyricsHeightPixels * verticalZoomFactor));

    trackBand.setY(newY);
    return newY + trackBand.getTotalHeight() + BETWEEN_TRACK_DIST_PIXELS;
  }

  private int resolution;
  private GenericTrack[] trackDescriptions;

  /**
   * Set the tracks for this song. All tracks should belong to the same
   * sequence, or at least have the same resolution and the same length. The
   * first track in the array is considered to be the director track.
   *
   * @deprecated This is a hack for the Requiem version
   * @param tracks
   */
  @Deprecated
  public void setRequiemTracks(final Track[] tracks, int resolution, GenericTrack[] trackDescriptions) {
    if (!SwingUtilities.isEventDispatchThread()) {
      throw new RuntimeException("Must be called from EventDispatchThread.");
    }

    try {
      clear();
      trackBands.clear();
      defaultPixelToMidiFactor = (4 * resolution) / MAESUREDEFAULTPX;

      int YPos = Band.PREF_BANDHEIGHT + DIRECTOR_TO_FIRST_TRACK_DIST;
      for (int i = 1; i < tracks.length; i++) {
        TrackBand trackBand = new TrackBand(SongPanel.this);
        trackBand.setTrack(tracks[i], resolution);
        trackBand.setBandHeight(DEFAULT_MIDI_BANDHEIGHT);
        trackBand.setLyricsHeightPixels((int) (TrackBand.defaultLyricsHeightPixels * verticalZoomFactor));
        trackBand.setY(YPos);

        // calculate y pos for the next track
        YPos = YPos + trackBand.getTotalHeight() + BETWEEN_TRACK_DIST_PIXELS;
        addBand(trackBand);
        trackBands.add(trackBand);
        if (trackDescriptions != null) {
          if (trackDescriptions.length > i) {
            if (trackDescriptions[i] != null) {
              TrackToBandConnector connector = new TrackToBandConnector(trackBand);
              logger.log(Level.FINER, "{0} adding to  {1} ", new Object[]{connector, trackDescriptions[i]});
              trackDescriptions[i].addNonAudioEventHandler(connector);
            }
          }
        }
      }
      leftVoidZone = new LeftVoidZone(SongPanel.this);
      addZone(leftVoidZone);
      rightVoidZone = new RightVoidZone(SongPanel.this);
      addZone(rightVoidZone);

      directorBand = new DirectorBand(SongPanel.this);
      addBand(directorBand);
      setDefaultDraggingLayer(directorBand);
      addZone(new LoopZone(SongPanel.this));
      addZone(new StartPointZone(SongPanel.this));
      addZone(new CursorZone(SongPanel.this));
      if (tracks.length > 0) {
        directorBand.setTrack(tracks[0], resolution);
      } else {
        directorBand.setTrack(null, resolution);
      }
      getDimensions().setLoopStartMidi(getDimensions().getMinimumMidi());
      getDimensions().setLoopEndMidi(getDimensions().getMaximumMidi());
      setPixelToMidiFactor(getDefaultPixelToMidiFactor());
      repaint();
    } catch (IOException ex) {
      Exceptions.printStackTrace(ex);
    }

  }

  /**
   * Get a PixelToMidiFactor that permits to display the currently loaded song
   * in a reasonable resolution.
   *
   * @return a proposed value for the PixelToMidiFactor.
   */
  public double getDefaultPixelToMidiFactor() {
    return defaultPixelToMidiFactor;
  }

  /**
   * Set horizontal size of the music. The PixelToMidiFactor indicates by which
   * value we have to multiply each pixel to give the corresponding position in
   * midi ticks. A larger value will display the music in a more condensed way.
   *
   * @param newPixelToMidiFactor
   */
  public void setPixelToMidiFactor(double newPixelToMidiFactor) {
    if (!SwingUtilities.isEventDispatchThread()) {
      throw new RuntimeException("Must be called from EventDispatchThread.");
    }
    getDimensions().setPixelToMidiFactor(newPixelToMidiFactor);
  }

  public long getMaximumMidi() {
    return getDimensions().getMaximumMidi();
  }

  public long getMinimumMidi() {
    return getDimensions().getMinimumMidi();
  }

  /**
   * Sets the cursor to the given tick-position and if necessary shifts the
   * viewport so that the cursor is in the visible area.
   *
   * @param tick the new position in Midi ticks.
   */
  public void setCursorVisible(long tick) {
    long rightBorder = getDimensions().getViewportLeftMidi() + getDimensions().getViewportWidthMidi();
    long leftBorder = getDimensions().getViewportLeftMidi();

    long margin = JUMPMARGINMIDI;//getDimensions().pixelToMidi(JUMPMARGIN);
    if ((rightBorder - leftBorder) <= 2 * margin) {

      margin = 0;
    }
    long rightLimit = rightBorder - margin;
    long leftLimit = leftBorder + margin;

    // if the cursor comes close to the right border, shift the viewport to
    // see the next page
    if (tick > rightLimit) {
      long newLeft = tick - margin;
      if (newLeft > getDimensions().getMaximumMidi() - getDimensions().getViewportWidthMidi()) {
        newLeft = getDimensions().getMaximumMidi() - getDimensions().getViewportWidthMidi();
      }
      if (newLeft < getDimensions().getMinimumMidi()) {
        newLeft = getDimensions().getMinimumMidi();
      }
      getDimensions().setViewportLeftMidi(newLeft);
    }
    // if the cursor comes close to the left border, shift the viewport to
    // see the previous page
    if (tick < leftLimit) {
      long newLeft = tick - getDimensions().getViewportWidthMidi() + margin;
      if (newLeft < getDimensions().getMinimumMidi()) {
        newLeft = getDimensions().getMinimumMidi();
      }
      if (newLeft > getDimensions().getMaximumMidi() - getDimensions().getViewportWidthMidi()) {
        newLeft = getDimensions().getMaximumMidi() - getDimensions().getViewportWidthMidi();
      }
      getDimensions().setViewportLeftMidi(newLeft);
    }
    getDimensions().setCursorMidi(tick);
  }

  private void synchronizeCursor() {
    if (session != null) {
      setCursorVisible((long) session.getTickPosition(0.05));
    }
  }

  private void sessionPlayingChanged(final boolean playing) {
    Runnable playingUpdateTask = new Runnable() {
      @Override
      public void run() {
        logger.log(Level.FINER, "sessionPlayingChanged( {0} )", playing);
        SongPanel.this.playing = playing;
        if (playing) {
          cursorTimer.start();
          setAnimated(true);
        } else {
          cursorTimer.stop();
          setAnimated(false);
        }
      }
    };
    SwingExecutor.instance().execute(playingUpdateTask);
  }

  public void connectSession(SongSession session) {
    this.session = session;
    SessionToViewConnector sessionToView = new SessionToViewConnector(getDimensions());
    session.addPropertyChangeListener(sessionToView);

    ViewToSessionConnector viewToSession = new ViewToSessionConnector(session);
    getDimensions().addPropertyChangeListener(viewToSession);

  }
}

/*
 * Copyright 2011 Harald Postner .
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.free_creations.songview2;

import de.free_creations.guicomponents.SwingExecutor;
import de.free_creations.midisong.GenericTrack;
import de.free_creations.midisong.GenericTrack.EventHandler;
import de.free_creations.midisong.SongSession;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.sound.midi.Track;
import javax.swing.SwingUtilities;
import javax.swing.Timer;
import org.openide.util.Exceptions;

/**
 *
 * @author Harald Postner <Harald at H-Postner.de>
 */
public class SongPanel extends SongCanvasImpl {

  static final private Logger logger = Logger.getLogger(SongPanel.class.getName());
  /**
   * The proposed size of one measure in pixels.
   */
  private static final double MAESUREDEFAULTPX = 100;
  /**
   * a PixelToMidiFactor that permits to display the currently loaded song in a
   * reasonable resolution. This value is automatically adjusted when a new
   * sequence is loaded.
   */
  private double defaultPixelToMidiFactor = 10.0D;

  private static class TrackToBandConnector implements EventHandler {

    private final TrackBand trackBand;

    public TrackToBandConnector(TrackBand trackBand) {
      this.trackBand = trackBand;
    }

    @Override
    public void onMuteChange(boolean value) {
      trackBand.setActive(!value);
    }

    @Override
    public void onAttenuationChange(float value) {
      //ignore
    }
  }
  /**
   * The size (in pixels) of the jump- margin on both window borders. When the
   * cursor moves into this margin the display will shift to the next page.
   */
  //private final long JUMPMARGIN = 20;
    /**
   * The size (in midiTick) of the jump- margin on both window borders. When the
   * cursor moves into this margin the display will shift to the next page.
   */
  private final long JUMPMARGINMIDI = 3*480; // one bar (assuming 3/4)

  private DirectorBand directorBand;
  private ArrayList<TrackBand> trackBands = new ArrayList<TrackBand>();
  private SongSession session = null;
  private final static int cursorUpdatePeriode = 100; // in milliseconds
  /**
   * The Handler that reacts on cursor update events generated by the cursor
   * timer.
   */
  private final ActionListener cursorUpdateTask = new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
      SongPanel.this.synchronizeCursor();
    }
  };
  private final Timer cursorTimer = new Timer(cursorUpdatePeriode, cursorUpdateTask);
  private LeftVoidZone leftVoidZone;
  private RightVoidZone rightVoidZone;
  private volatile boolean playing = false;

  /**
   * The sessionListener monitors the song-session to see when it starts or
   * stops playing.
   */
  /**
   * This class transmits changes of the song-session to the song display.
   */
  private class SessionToViewConnector implements PropertyChangeListener {

    private final Dimensions dimensions;

    public SessionToViewConnector(Dimensions dimensions) {
      this.dimensions = dimensions;
    }

    @Override
    public void propertyChange(PropertyChangeEvent evt) {
      if (SongSession.PROP_PLAYING.equals(evt.getPropertyName())) {
        boolean playing = (Boolean) evt.getNewValue();
        SongPanel.this.sessionPlayingChanged(playing);
      } else if (SongSession.PROP_STARTPOINT.equals(evt.getPropertyName())) {
        dimensions.setStartPointMidi((Long) evt.getNewValue());
        setCursorVisible((Long) evt.getNewValue());
      } else if (SongSession.PROP_LOOPSTARTPOINT.equals(evt.getPropertyName())) {
        dimensions.setLoopStartMidi((Long) evt.getNewValue());
      } else if (SongSession.PROP_LOOPENDPOINT.equals(evt.getPropertyName())) {
        dimensions.setLoopEndMidi((Long) evt.getNewValue());
      } else if (SongSession.PROP_LOOPING.equals(evt.getPropertyName())) {
        setLoopActive((Boolean) evt.getNewValue());
      }
    }
  }

  /**
   * This class transmits changes of the song-display to the song-Session.
   */
  private class ViewToSessionConnector implements PropertyChangeListener {

    private final SongSession session;

    public ViewToSessionConnector(SongSession session) {
      this.session = session;
    }

    @Override
    public void propertyChange(PropertyChangeEvent evt) {
      if (Prop.STARTPOINT_MIDI.equals(evt.getPropertyName())) {
        session.setStartPoint((Long) evt.getNewValue());
      } else if (Prop.LOOPSTART_MIDI.equals(evt.getPropertyName())) {
        session.setLoopStartPoint((Long) evt.getNewValue());
      } else if (Prop.LOOPEND_MIDI.equals(evt.getPropertyName())) {
        session.setLoopEndPoint((Long) evt.getNewValue());
      }
    }
  }

  /**
   * Paint an example for use in an application construction environment.
   */
  private class DesignTimePainter implements Runnable {

    @Override
    public void run() {
      try {
        getDimensions().setPixelToMidiFactor(30.0D);
        getDimensions().setMinimumPixel(-20);
        getDimensions().setMaximumPixel(600);
        getDimensions().setLoopStartPixel(20);
        getDimensions().setLeadInEndPixel(150);
        getDimensions().setLeadOutStartPixel(400);
        getDimensions().setLoopEndPixel(450);

        getDimensions().setStartPointPixel(180);
        getDimensions().setCursorPixel(200);

        addZone(new LeftVoidZone(SongPanel.this));
        //addZone(new LeadInZone(SongPanel.this));
        //addZone(new LeadOutZone(SongPanel.this));
        addZone(new RightVoidZone(SongPanel.this));

        TrackBand trackBand = new TrackBand(SongPanel.this);
        trackBand.setY(80);
        addBand(trackBand);
        trackBands.add(trackBand);
        directorBand = new DirectorBand(SongPanel.this);
        addBand(directorBand);
        setDefaultDraggingLayer(directorBand);

        addZone(new LoopZone(SongPanel.this));
        addZone(new StartPointZone(SongPanel.this));
        addZone(new CursorZone(SongPanel.this));
        repaint();
      } catch (IOException ex) {
        Exceptions.printStackTrace(ex);
      }
    }
  }

  /**
   * Builds a song panel. If we are running in an application construction
   * environment (i.e. NetBeans Matisse GUI Builder) this constructor will
   * display an example with one track. In a runtime environment this
   * constructor will display an empty panel.
   */
  public SongPanel() {
    this(java.beans.Beans.isDesignTime());
  }

  /**
   * This constructor is package private and might be used to test the
   * designTime feature.
   *
   * @param designTime set to true to start in design-time mode.
   */
  SongPanel(final boolean designTime) {
    super();
    if (designTime) {
      SwingUtilities.invokeLater(new DesignTimePainter());
    }
  }

  void setLoopActive(boolean active) {
    if (!SwingUtilities.isEventDispatchThread()) {
      throw new RuntimeException("Must be called from EventDispatchThread.");
    }
    rightVoidZone.setActive(active);
    leftVoidZone.setActive(active);
  }

  public void setEnabled(int trackIndex, boolean enabled) {
    if (!SwingUtilities.isEventDispatchThread()) {
      throw new RuntimeException("Must be called from EventDispatchThread.");
    }
    TrackBand track = trackBands.get(trackIndex);
    track.setEnabled(enabled);
  }

  /**
   * Set the tracks for this song. All tracks should belong to the same
   * sequence, or at least have the same resolution and the same length. The
   * first track in the array is considered to be the director track.
   *
   * @deprecated This is a hack for the Requiem version
   * @param tracks
   */
  @Deprecated
  public void setRequiemTracks(final Track[] tracks, int resolution, GenericTrack[] trackDescriptions) {
    if (!SwingUtilities.isEventDispatchThread()) {
      throw new RuntimeException("Must be called from EventDispatchThread.");
    }
    try {
      clear();
      defaultPixelToMidiFactor = (4 * resolution) / MAESUREDEFAULTPX;
      leftVoidZone = new LeftVoidZone(SongPanel.this);
      addZone(leftVoidZone);
      //addZone(new LeadInZone(SongPanel.this));
      //addZone(new LeadOutZone(SongPanel.this));
      rightVoidZone = new RightVoidZone(SongPanel.this);
      addZone(rightVoidZone);
      int YPos = Band.PREF_BANDHEIGHT + 10;
      for (int i = 1; i < tracks.length; i++) {
        TrackBand trackBand = new TrackBand(SongPanel.this);
        trackBand.setTrack(tracks[i], resolution);
        trackBand.setBandHeight(25);//<<<<<<<<<<<< make this configurable
        trackBand.setY(YPos);
        YPos = YPos + trackBand.getTotalHeight() + 20;
        addBand(trackBand);
        trackBands.add(trackBand);
        if (trackDescriptions != null) {
          if (trackDescriptions.length > i) {
            if (trackDescriptions[i] != null) {
              TrackToBandConnector connector = new TrackToBandConnector(trackBand);
              logger.log(Level.FINER, "{0} adding to  {1} ", new Object[]{connector, trackDescriptions[i]});
              trackDescriptions[i].addNonAudioEventHandler(connector);
            }
          }
        }
      }
      directorBand = new DirectorBand(SongPanel.this);
      addBand(directorBand);
      setDefaultDraggingLayer(directorBand);
      addZone(new LoopZone(SongPanel.this));
      addZone(new StartPointZone(SongPanel.this));
      addZone(new CursorZone(SongPanel.this));
      if (tracks.length > 0) {
        directorBand.setTrack(tracks[0], resolution);
      } else {
        directorBand.setTrack(null, resolution);
      }
      getDimensions().setLoopStartMidi(getDimensions().getMinimumMidi());
      getDimensions().setLoopEndMidi(getDimensions().getMaximumMidi());
      setPixelToMidiFactor(getDefaultPixelToMidiFactor());
      repaint();
    } catch (IOException ex) {
      Exceptions.printStackTrace(ex);
    }

  }

  /**
   * Get a PixelToMidiFactor that permits to display the currently loaded song
   * in a reasonable resolution.
   *
   * @return a proposed value for the PixelToMidiFactor.
   */
  public double getDefaultPixelToMidiFactor() {
    return defaultPixelToMidiFactor;
  }

  /**
   * Set horizontal size of the music. The PixelToMidiFactor indicates by which
   * value we have to multiply each pixel to give the corresponding position in
   * midi ticks. A larger value will display the music in a more condensed way.
   *
   * @param newPixelToMidiFactor
   */
  public void setPixelToMidiFactor(double newPixelToMidiFactor) {
    if (!SwingUtilities.isEventDispatchThread()) {
      throw new RuntimeException("Must be called from EventDispatchThread.");
    }
    getDimensions().setPixelToMidiFactor(newPixelToMidiFactor);
  }

  public long getMaximumMidi() {
    return getDimensions().getMaximumMidi();
  }

  public long getMinimumMidi() {
    return getDimensions().getMinimumMidi();
  }

  /**
   * Sets the cursor to the given tick-position and if necessary shifts the
   * viewport so that the cursor is in the visible area.
   *
   * @param tick the new position in Midi ticks.
   */
  public void setCursorVisible(long tick) {
    long rightBorder = getDimensions().getViewportLeftMidi() + getDimensions().getViewportWidthMidi();
    long leftBorder = getDimensions().getViewportLeftMidi();


    long margin = JUMPMARGINMIDI;//getDimensions().pixelToMidi(JUMPMARGIN);
    if ((rightBorder - leftBorder) <= 2 * margin) {

      margin = 0;
    }
    long rightLimit = rightBorder - margin;
    long leftLimit = leftBorder + margin;

    // if the cursor comes close to the right border, shift the viewport to
    // see the next page
    if (tick > rightLimit) {
      long newLeft = tick - margin;
      if (newLeft > getDimensions().getMaximumMidi() - getDimensions().getViewportWidthMidi()) {
        newLeft = getDimensions().getMaximumMidi() - getDimensions().getViewportWidthMidi();
      }
      if (newLeft < getDimensions().getMinimumMidi()) {
        newLeft = getDimensions().getMinimumMidi();
      }
      getDimensions().setViewportLeftMidi(newLeft);
    }
    // if the cursor comes close to the left border, shift the viewport to
    // see the previous page
    if (tick < leftLimit) {
      long newLeft = tick - getDimensions().getViewportWidthMidi() + margin;
      if (newLeft < getDimensions().getMinimumMidi()) {
        newLeft = getDimensions().getMinimumMidi();
      }
      if (newLeft > getDimensions().getMaximumMidi() - getDimensions().getViewportWidthMidi()) {
        newLeft = getDimensions().getMaximumMidi() - getDimensions().getViewportWidthMidi();
      }
      getDimensions().setViewportLeftMidi(newLeft);
    }
    getDimensions().setCursorMidi(tick);
  }

  private void synchronizeCursor() {
    if (session != null) {
      setCursorVisible(session.getCursor());
    }
  }

  private void sessionPlayingChanged(final boolean playing) {
    Runnable playingUpdateTask = new Runnable() {
      @Override
      public void run() {
        logger.log(Level.FINER, "sessionPlayingChanged( {0} )", playing);
        SongPanel.this.playing = playing;
        if (playing) {
          cursorTimer.start();
          setAnimated(true);
        } else {
          cursorTimer.stop();
          setAnimated(false);
        }
      }
    };
    SwingExecutor.instance().execute(playingUpdateTask);
  }

  public void connectSession(SongSession session) {
    this.session = session;
    SessionToViewConnector sessionToView = new SessionToViewConnector(getDimensions());
    session.addPropertyChangeListener(sessionToView);

    ViewToSessionConnector viewToSession = new ViewToSessionConnector(session);
    getDimensions().addPropertyChangeListener(viewToSession);


  }
}
